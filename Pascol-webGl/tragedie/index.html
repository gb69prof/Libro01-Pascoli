<!doctype html>
<html lang="it">
<head>
<meta charset="utf-8"/>
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
<title>Dal buio al nido — Pascoli (WebGL)</title>
<style>
  html,body{margin:0;height:100%;background:#07080b;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
  #wrap{position:fixed;inset:0;}
  canvas{position:absolute;inset:0;width:100%;height:100%;display:block;}
  #fx{pointer-events:none;mix-blend-mode:screen;}
  .hud{position:fixed;left:12px;right:12px;top:12px;display:flex;gap:10px;justify-content:space-between;align-items:center;z-index:3;}
  .chip{backdrop-filter:blur(10px);background:rgba(18,20,26,.45);border:1px solid rgba(255,255,255,.12);
        color:rgba(255,255,255,.88);border-radius:14px;padding:10px 12px;box-shadow:0 12px 36px rgba(0,0,0,.42);}
  .chip b{color:rgba(255,215,150,.98)}
  .controls{position:fixed;bottom:14px;left:14px;right:14px;display:flex;justify-content:space-between;align-items:center;gap:12px;z-index:3;}
  .btn{width:66px;height:66px;border-radius:18px;border:1px solid rgba(255,255,255,.16);background:rgba(255,255,255,.07);
       display:flex;align-items:center;justify-content:center;box-shadow:0 14px 40px rgba(0,0,0,.46);
       backdrop-filter:blur(10px);cursor:pointer;user-select:none;-webkit-tap-highlight-color:transparent;}
  .btn:active{transform:translateY(1px);}
  .btn img{width:36px;height:36px;opacity:.96}
  .speed{flex:1;max-width:560px;margin:0 auto;display:flex;gap:10px;align-items:center;justify-content:center;}
  .speed label{color:rgba(255,255,255,.82);font-size:13px;}
  input[type="range"]{width:min(560px,62vw);}
  .vignette{position:fixed;inset:0;pointer-events:none;z-index:2;
    background:radial-gradient(ellipse at center, rgba(0,0,0,0.08) 0%, rgba(0,0,0,0.55) 70%, rgba(0,0,0,0.92) 100%);}
</style>
</head>
<body>
<div id="wrap">
  <canvas id="gl"></canvas>
  <canvas id="fx"></canvas>
</div>

<div class="hud">
  <div class="chip"><b>Dal buio al nido</b> — cammina: le tragedie sono davanti a te. Attraversale per “rompere” il buio.</div>
  <div class="chip" id="pos">z: 0</div>
</div>

<div class="controls">
  <div class="btn" id="back" aria-label="Indietro"><img src="assets/arrow_left.svg" alt=""></div>
  <div class="speed">
    <label for="spd">Velocità</label>
    <input id="spd" type="range" min="0.35" max="2.6" step="0.05" value="1.1"/>
  </div>
  <div class="btn" id="forward" aria-label="Avanti"><img src="assets/arrow_right.svg" alt=""></div>
</div>

<div class="vignette"></div>

<script>
(() => {
  const clamp=(v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp=(a,b,t)=>a+(b-a)*t;

  const canvas=document.getElementById('gl');
  const fx=document.getElementById('fx');
  const ctx=fx.getContext('2d');
  const btnF=document.getElementById('forward');
  const btnB=document.getElementById('back');
  const spd=document.getElementById('spd');
  const posEl=document.getElementById('pos');

  const gl=canvas.getContext('webgl',{alpha:false,antialias:true});
  if(!gl){ alert('WebGL non disponibile.'); return; }

  const vs=`
    attribute vec2 aPos;
    attribute vec2 aUV;
    uniform mat4 uMVP;
    varying vec2 vUV;
    void main(){ vUV=aUV; gl_Position=uMVP*vec4(aPos,0.0,1.0); }
  `;
  const fs=`
    precision mediump float;
    varying vec2 vUV;
    uniform sampler2D uTex;
    uniform float uOpacity;
    uniform vec3 uTint;
    void main(){
      vec4 c = texture2D(uTex, vUV);
      // leggero lift per far "vedere" l'immagine sul buio
      c.rgb = mix(uTint, c.rgb, 0.92);
      gl_FragColor = vec4(c.rgb, c.a*uOpacity);
    }
  `;
  function compile(type,src){
    const s=gl.createShader(type);
    gl.shaderSource(s,src); gl.compileShader(s);
    if(!gl.getShaderParameter(s,gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(s)); throw new Error('shader'); }
    return s;
  }
  function makeProgram(vsSrc,fsSrc){
    const p=gl.createProgram();
    gl.attachShader(p,compile(gl.VERTEX_SHADER,vsSrc));
    gl.attachShader(p,compile(gl.FRAGMENT_SHADER,fsSrc));
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p,gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(p)); throw new Error('link'); }
    return p;
  }
  const prog=makeProgram(vs,fs);
  gl.useProgram(prog);

  const locPos=gl.getAttribLocation(prog,'aPos');
  const locUV=gl.getAttribLocation(prog,'aUV');
  const locMVP=gl.getUniformLocation(prog,'uMVP');
  const locOp=gl.getUniformLocation(prog,'uOpacity');
  const locTint=gl.getUniformLocation(prog,'uTint');

  // Quad 2D [-1,1]
  const vbo=gl.createBuffer();
  gl.bindBuffer(gl.ARRAY_BUFFER,vbo);
  const quad=new Float32Array([
    -1,-1, 0,1,
     1,-1, 1,1,
     1, 1, 1,0,
    -1, 1, 0,0
  ]);
  gl.bufferData(gl.ARRAY_BUFFER,quad,gl.STATIC_DRAW);
  gl.enableVertexAttribArray(locPos);
  gl.vertexAttribPointer(locPos,2,gl.FLOAT,false,16,0);
  gl.enableVertexAttribArray(locUV);
  gl.vertexAttribPointer(locUV,2,gl.FLOAT,false,16,8);

  const ibo=gl.createBuffer();
  gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER,ibo);
  gl.bufferData(gl.ELEMENT_ARRAY_BUFFER,new Uint16Array([0,1,2,0,2,3]),gl.STATIC_DRAW);

  function loadTex(url){
    return new Promise((resolve,reject)=>{
      const img=new Image();
      img.onload=()=>{
        const tex=gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D,tex);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL,true);
        gl.texImage2D(gl.TEXTURE_2D,0,gl.RGBA,gl.RGBA,gl.UNSIGNED_BYTE,img);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MIN_FILTER,gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_MAG_FILTER,gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_S,gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D,gl.TEXTURE_WRAP_T,gl.CLAMP_TO_EDGE);
        resolve({tex,w:img.width,h:img.height});
      };
      img.onerror=reject;
      img.src=url;
    });
  }

  // Mat4 helpers (column-major for WebGL)
  function mat4(){ return new Float32Array([1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]); }
  function mul(a,b){
    const o=new Float32Array(16);
    for(let c=0;c<4;c++) for(let r=0;r<4;r++){
      o[c*4+r]=a[0*4+r]*b[c*4+0]+a[1*4+r]*b[c*4+1]+a[2*4+r]*b[c*4+2]+a[3*4+r]*b[c*4+3];
    }
    return o;
  }
  function translate(x,y,z){
    const m=mat4(); m[12]=x; m[13]=y; m[14]=z; return m;
  }
  function scale(x,y,z){
    const m=mat4(); m[0]=x; m[5]=y; m[10]=z; return m;
  }
  function perspective(fovy,aspect,near,far){
    const f=1/Math.tan(fovy/2), nf=1/(near-far);
    const m=new Float32Array(16);
    m[0]=f/aspect; m[5]=f; m[10]=(far+near)*nf; m[11]=-1;
    m[14]=(2*far*near)*nf;
    return m;
  }

  function resize(){
    const dpr=Math.min(2,window.devicePixelRatio||1);
    canvas.width=Math.floor(canvas.clientWidth*dpr);
    canvas.height=Math.floor(canvas.clientHeight*dpr);
    fx.width=canvas.width; fx.height=canvas.height;
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  window.addEventListener('resize',resize); resize();

  // FX explosion particles
  let particles=[];
  function explode(){
    const cx=fx.width*0.5, cy=fx.height*0.52;
    particles=[];
    for(let i=0;i<260;i++){
      const a=Math.random()*Math.PI*2;
      const sp=2.5+Math.random()*12;
      particles.push({x:cx,y:cy,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp*0.85,life:980+Math.random()*650,r:1.2+Math.random()*3.8,h:34+Math.random()*35});
    }
  }
  function drawFX(dt){
    ctx.clearRect(0,0,fx.width,fx.height);
    if(!particles.length) return;
    ctx.globalCompositeOperation='lighter';
    for(const p of particles){
      p.life-=dt; if(p.life<=0) continue;
      p.vx*=0.985; p.vy=p.vy*0.985+0.03;
      p.x+=p.vx; p.y+=p.vy;
      const a=clamp(p.life/1500,0,1);
      ctx.fillStyle=`hsla(${p.h},92%,72%,${a*0.9})`;
      ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
    }
    particles=particles.filter(p=>p.life>0);
    ctx.globalCompositeOperation='source-over';
  }

  // Movement
  let moving=0;
  const press=(el,dir)=>{
    const start=()=>moving=dir;
    const end=()=>moving=0;
    el.addEventListener('pointerdown',(e)=>{ e.preventDefault(); el.setPointerCapture(e.pointerId); start(); });
    el.addEventListener('pointerup',end);
    el.addEventListener('pointercancel',end);
    el.addEventListener('pointerleave',end);
  };
  press(btnF, +1);
  press(btnB, -1);

  // Camera position along Z.
  // Start "before" the first image so it is visible ahead.
  let camZ = 4.0;         // bigger = farther back (see first scene clearly)
  let speedBase = 0.008;  // tuned for dt in ms

  const Z_TRAG = -8.0;
  const Z_NIDO = -22.0;

  let triggered=false;
  let fadeTrag=1.0, fadeNido=0.0;
  let nidoLock=false;

  // GL state
  gl.disable(gl.DEPTH_TEST); // to avoid quads hiding each other
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  function clear(){
    // slightly brighter so transparency "reads"
    gl.clearColor(0.03,0.035,0.055,1);
    gl.clear(gl.COLOR_BUFFER_BIT);
  }

  function drawBillboard(texInfo, worldZ, opacity, tintRGB){
    const aspect = texInfo.w/texInfo.h;
    const a = canvas.width/canvas.height;

    // size: make it always readable, a bit larger on portrait
    let base = (a < 1.15) ? 1.25 : 1.05;
    // fake perspective: scale with distance
    const dz = Math.abs((worldZ - camZ));
    const k = clamp(1.35 / (0.55 + dz*0.10), 0.45, 1.25);

    const sx = base * k;
    const sy = base * k / aspect;

    const model = mul( translate(0, 0.05, worldZ), scale(sx, sy, 1) );
    const proj  = perspective(55*Math.PI/180, a, 0.1, 200);
    const view  = translate(0, 0, -camZ);
    const mvp   = mul(proj, mul(view, model));

    gl.uniformMatrix4fv(locMVP, false, mvp);
    gl.uniform1f(locOp, opacity);
    gl.uniform3f(locTint, tintRGB[0], tintRGB[1], tintRGB[2]);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texInfo.tex);
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
  }

  Promise.all([loadTex('assets/tragedie.png'), loadTex('assets/nido.png')]).then(([trag,nido])=>{
    let last=performance.now();

    function tick(now){
      const dt=now-last; last=now;

      // move: forward makes camZ decrease (towards negative)
      const v = speedBase * parseFloat(spd.value) * dt;
      camZ += (moving>0 ? -v : moving<0 ? +v : 0);

      // bounds: keep a clear path
      camZ = clamp(camZ, -40, 10);

      posEl.textContent = `z: ${camZ.toFixed(1)}`;

      // Trigger when camera passes through tragedy plane (slightly beyond it)
      if(!triggered && camZ < (Z_TRAG - 0.7)){
        triggered=true;
        explode();
        nidoLock=true;
      }

      if(triggered){
        fadeTrag = lerp(fadeTrag, 0.0, 0.035);
        fadeNido = lerp(fadeNido, 1.0, 0.03);

        // gentle auto-step after explosion to "land" near nido
        if(nidoLock){
          const target = -16.0;
          camZ = lerp(camZ, target, 0.02);
          if(Math.abs(camZ-target) < 0.25) nidoLock=false;
        }
      }

      clear();

      // subtle glow plates behind each scene to make them visible
      drawBillboard(trag, Z_TRAG-0.7, 0.10, [0.25,0.20,0.15]);
      drawBillboard(nido, Z_NIDO-0.7, 0.10, [0.15,0.20,0.25]);

      // main scenes
      if(fadeTrag>0.02) drawBillboard(trag, Z_TRAG, fadeTrag, [0.10,0.10,0.12]);
      if(fadeNido>0.01) drawBillboard(nido, Z_NIDO, fadeNido, [0.10,0.10,0.12]);

      drawFX(dt);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  }).catch(err=>{
    console.error(err);
    alert('Errore nel caricamento delle immagini (assets).');
  });

})();
</script>
</body>
</html>
