<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
  <title>Pascoli — Dal buio al nido</title>
  <style>
    html, body { margin:0; height:100%; overflow:hidden; background:#050607; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; }
    canvas { display:block; }
    .hud { position: fixed; left: 0; top: 0; right: 0; display:flex; justify-content: space-between; align-items: center; padding: 10px 12px; pointer-events: none; }
    .left, .right { display:flex; gap:10px; align-items:center; }
    .panel { pointer-events: auto; backdrop-filter: blur(10px); background: rgba(20, 22, 26, 0.50); border: 1px solid rgba(255,255,255,0.08); border-radius: 14px; padding: 10px 12px; box-shadow: 0 10px 30px rgba(0,0,0,0.35); color: rgba(255,255,255,0.92); }
    .title { font-weight: 650; letter-spacing: 0.2px; font-size: 14px; color: rgba(255, 215, 120, 0.95); margin: 0 0 6px 0; }
    .hint { font-size: 12px; color: rgba(255,255,255,0.75); line-height: 1.2; }
    .btnRow { display:flex; gap:10px; margin-top:8px; }
    .btn { pointer-events:auto; border: 1px solid rgba(255,255,255,0.10); background: rgba(255,255,255,0.06); color: rgba(255,255,255,0.92); border-radius: 14px; padding: 10px 14px; font-weight: 650; cursor: pointer; user-select:none; touch-action: manipulation; }
    .btn:active { transform: translateY(1px); }
    .sliderWrap { display:flex; flex-direction: column; gap:6px; min-width: 220px; }
    input[type="range"] { width: 220px; }
    .small { font-size: 12px; color: rgba(255,255,255,0.72); display:flex; justify-content:space-between; }
    .fade { position: fixed; inset: 0; background: radial-gradient(ellipse at center, rgba(0,0,0,0.05) 0%, rgba(0,0,0,0.55) 70%, rgba(0,0,0,0.88) 100%); pointer-events:none; mix-blend-mode: multiply; }
    .bottom { position: fixed; left: 0; right: 0; bottom: 10px; display:flex; justify-content:center; gap:12px; pointer-events:none; }
    .bottom .btn { padding: 14px 18px; border-radius: 18px; font-size: 16px; }
  </style>
</head>
<body>
  <div class="hud">
    <div class="left panel">
      <div class="title">Dal buio al nido</div>
      <div class="hint">W / ↑ avanti — S / ↓ indietro. Trascina per guardare.</div>
      <div class="btnRow">
        <button class="btn" id="btnBack">← Indietro</button>
        <button class="btn" id="btnForward">Avanti →</button>
      </div>
    </div>
    <div class="right panel sliderWrap">
      <div class="title">Velocità</div>
      <input id="speed" type="range" min="0.4" max="3.0" step="0.1" value="1.2" />
      <div class="small"><span>Lenta</span><span id="speedVal">1.2×</span><span>Veloce</span></div>
    </div>
  </div>

  <div class="bottom">
    <button class="btn" id="btnBack2">←</button>
    <button class="btn" id="btnForward2">→</button>
  </div>

  <div class="fade"></div>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.160.0/build/three.module.js';

    const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: false });
    renderer.setPixelRatio(Math.min(2, window.devicePixelRatio));
    renderer.setSize(window.innerWidth, window.innerHeight);
    renderer.outputColorSpace = THREE.SRGBColorSpace;
    document.body.appendChild(renderer.domElement);

    const scene = new THREE.Scene();
    scene.fog = new THREE.FogExp2(0x050607, 0.06);

    const camera = new THREE.PerspectiveCamera(65, window.innerWidth / window.innerHeight, 0.1, 200);
    // Partenza PRIMA della prima immagine (che risulta subito visibile davanti).
    camera.position.set(0, 1.6, 3.2);

    const ambient = new THREE.AmbientLight(0x9aa6b2, 0.25);
    scene.add(ambient);

    const key = new THREE.PointLight(0xffd6a0, 1.0, 30, 2);
    key.position.set(0, 2.4, 0);
    scene.add(key);

    const back = new THREE.PointLight(0x8fb9ff, 0.35, 60, 2);
    back.position.set(0, 3.0, -30);
    scene.add(back);

    const corridorLen = 70;
    const corridorW = 6;
    const corridorH = 3.6;

    const floor = new THREE.Mesh(
      new THREE.PlaneGeometry(corridorW, corridorLen),
      new THREE.MeshStandardMaterial({ color: 0x0d0f12, roughness: 0.85, metalness: 0.05 })
    );
    floor.rotation.x = -Math.PI/2;
    floor.position.set(0, 0, -corridorLen/2 + 6);
    scene.add(floor);

    const wallMat = new THREE.MeshStandardMaterial({ color: 0x0a0b0d, roughness: 0.95 });
    const wallGeo = new THREE.PlaneGeometry(corridorLen, corridorH);

    const wallL = new THREE.Mesh(wallGeo, wallMat);
    wallL.rotation.y = Math.PI/2;
    wallL.position.set(-corridorW/2, corridorH/2, -corridorLen/2 + 6);
    scene.add(wallL);

    const wallR = new THREE.Mesh(wallGeo, wallMat);
    wallR.rotation.y = -Math.PI/2;
    wallR.position.set(corridorW/2, corridorH/2, -corridorLen/2 + 6);
    scene.add(wallR);

    const ceiling = new THREE.Mesh(
      new THREE.PlaneGeometry(corridorW, corridorLen),
      new THREE.MeshStandardMaterial({ color: 0x08090b, roughness: 0.95 })
    );
    ceiling.rotation.x = Math.PI/2;
    ceiling.position.set(0, corridorH, -corridorLen/2 + 6);
    scene.add(ceiling);

    // Light pools
    for (let i=0; i<9; i++){
      const p = new THREE.PointLight(0xffc98b, 0.55, 18, 2.2);
      p.position.set((i%2===0 ? -1.8 : 1.8), 2.2, -i*7 - 4);
      scene.add(p);
    }

    const loader = new THREE.TextureLoader();

    function makeImagePlane(url, w, h, z){
      const tex = loader.load(url);
      tex.colorSpace = THREE.SRGBColorSpace;
      tex.minFilter = THREE.LinearMipmapLinearFilter;
      tex.magFilter = THREE.LinearFilter;

      const mat = new THREE.MeshStandardMaterial({
        map: tex,
        transparent: true,
        side: THREE.DoubleSide,
        depthWrite: false,
        roughness: 0.65,
        emissive: new THREE.Color(0x110c08),
        emissiveIntensity: 0.6,
      });

      const mesh = new THREE.Mesh(new THREE.PlaneGeometry(w, h), mat);
      mesh.position.set(0, 1.7, z);

      // FIX "al contrario": ribalto orizzontalmente il piano.
      mesh.scale.x = -1;

      scene.add(mesh);
      return { mesh, mat };
    }

    const tragedieZ = -8;
    const nidoZ = -22;

    const tragedie = makeImagePlane('assets/tragedie.png', 5.8, 3.9, tragedieZ);
    const nido     = makeImagePlane('assets/nido.png',     6.0, 3.9, nidoZ);
    nido.mat.opacity = 0.0;

    // --- Shatter (spezzatura) ---
    const shardsGroup = new THREE.Group();
    shardsGroup.visible = false;
    scene.add(shardsGroup);

    function buildShardsFrom(srcMesh, cols=12, rows=7){
      while(shardsGroup.children.length) shardsGroup.remove(shardsGroup.children[0]);

      const w = srcMesh.geometry.parameters.width;
      const h = srcMesh.geometry.parameters.height;
      const tileGeo = new THREE.PlaneGeometry(w/cols, h/rows);

      const baseTex = srcMesh.material.map;

      for(let r=0; r<rows; r++){
        for(let c=0; c<cols; c++){
          const u0 = c/cols, v0 = r/rows;
          const u1 = (c+1)/cols, v1 = (r+1)/cols;

          const tex = baseTex.clone();
          tex.needsUpdate = true;
          tex.repeat.set(1/cols, 1/rows);
          tex.offset.set(u0, 1 - v1);
          tex.colorSpace = THREE.SRGBColorSpace;

          const mat = new THREE.MeshStandardMaterial({
            map: tex,
            transparent: true,
            side: THREE.DoubleSide,
            depthWrite: false,
            roughness: 0.7,
            emissive: new THREE.Color(0x120c09),
            emissiveIntensity: 0.55,
          });

          const m = new THREE.Mesh(tileGeo, mat);

          const x = (c + 0.5 - cols/2) * (w/cols);
          const y = (rows/2 - (r + 0.5)) * (h/rows);

          m.position.set(srcMesh.position.x + x, srcMesh.position.y + y, srcMesh.position.z);

          // stesso fix specchio
          m.scale.x = -1;

          const dx = (c + 0.5 - cols/2) / cols;
          const dy = (r + 0.5 - rows/2) / rows;
          m.userData.vx = dx * (0.9 + Math.random()*0.8);
          m.userData.vy = dy * (0.9 + Math.random()*0.8);
          m.userData.vz = (0.6 + Math.random()*0.9);
          m.userData.spin = (Math.random()-0.5) * 0.9;
          m.userData.life = 0;

          shardsGroup.add(m);
        }
      }
    }

    let transitioning = false;
    let transitionT = 0;

    function startTransition(){
      if(transitioning) return;
      transitioning = true;
      transitionT = 0;
      buildShardsFrom(tragedie.mesh, 12, 7);
      shardsGroup.visible = true;

      // nasconde la plane originale
      tragedie.mat.opacity = 0.0;
      nido.mat.opacity = 0.0;
    }

    // Drag look
    let isDragging = false, lastX=0, lastY=0;
    let yaw=0, pitch=0;
    const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));

    addEventListener('pointerdown', (e)=>{ isDragging=true; lastX=e.clientX; lastY=e.clientY; });
    addEventListener('pointerup', ()=> isDragging=false);
    addEventListener('pointermove', (e)=>{
      if(!isDragging) return;
      const dx=e.clientX-lastX, dy=e.clientY-lastY;
      lastX=e.clientX; lastY=e.clientY;
      yaw -= dx*0.0022;
      pitch -= dy*0.0022;
      pitch = clamp(pitch, -0.5, 0.5);
      camera.rotation.set(pitch, yaw, 0);
    });

    // Movement controls
    const keys = { forward:false, back:false };
    addEventListener('keydown', (e)=>{
      if (e.key==='w'||e.key==='ArrowUp') keys.forward=true;
      if (e.key==='s'||e.key==='ArrowDown') keys.back=true;
    });
    addEventListener('keyup', (e)=>{
      if (e.key==='w'||e.key==='ArrowUp') keys.forward=false;
      if (e.key==='s'||e.key==='ArrowDown') keys.back=false;
    });

    const hook = (btn, which)=>{
      btn.addEventListener('pointerdown', (e)=>{ e.preventDefault(); keys[which]=true; });
      btn.addEventListener('pointerup', ()=> keys[which]=false);
      btn.addEventListener('pointerleave', ()=> keys[which]=false);
      btn.addEventListener('touchstart', (e)=>{ e.preventDefault(); keys[which]=true; }, {passive:false});
      btn.addEventListener('touchend', ()=> keys[which]=false);
    };
    hook(document.getElementById('btnForward'), 'forward');
    hook(document.getElementById('btnForward2'), 'forward');
    hook(document.getElementById('btnBack'), 'back');
    hook(document.getElementById('btnBack2'), 'back');

    const speedEl = document.getElementById('speed');
    const speedVal = document.getElementById('speedVal');
    let speed = parseFloat(speedEl.value);
    speedEl.addEventListener('input', ()=>{
      speed = parseFloat(speedEl.value);
      speedVal.textContent = speed.toFixed(1) + '×';
    });

    const zMin = -60, zMax = 6;
    const clock = new THREE.Clock();

    function animate(){
      requestAnimationFrame(animate);
      const dt = Math.min(0.05, clock.getDelta());
      const t = clock.elapsedTime;

      const moveDir = (keys.forward ? -1 : 0) + (keys.back ? 1 : 0);
      camera.position.z = clamp(camera.position.z + moveDir * dt * 2.0 * speed, zMin, zMax);

      // Trigger quando la camera attraversa la prima immagine
      if (!transitioning && camera.position.z < (tragedieZ - 0.8)) {
        startTransition();
      }

      if (transitioning) {
        transitionT += dt;

        const spread = 1.45;
        const fadeStart = 0.35;
        const fadeEnd = 1.2;

        shardsGroup.children.forEach((m)=>{
          m.userData.life += dt;
          m.position.x += m.userData.vx * dt * spread;
          m.position.y += m.userData.vy * dt * spread;
          m.position.z += m.userData.vz * dt * 2.2;
          m.rotation.z += m.userData.spin * dt;

          const life = m.userData.life;
          let a = 1.0;
          if (life > fadeStart) {
            a = 1.0 - clamp((life - fadeStart) / (fadeEnd - fadeStart), 0, 1);
          }
          m.material.opacity = a;
        });

        // dissolve-in del nido
        const nidoIn = clamp((transitionT - 0.35) / 0.9, 0, 1);
        nido.mat.opacity = nidoIn;

        if (transitionT > 1.5) {
          shardsGroup.visible = false;
          nido.mat.opacity = 1.0;
        }
      } else {
        tragedie.mat.opacity = 1.0;
        nido.mat.opacity = 0.0;
      }

      key.intensity = 0.85 + Math.sin(t*0.9)*0.15;
      scene.fog.density = 0.055 + Math.sin(t*0.35)*0.004;

      renderer.render(scene, camera);
    }
    animate();

    addEventListener('resize', ()=>{
      camera.aspect = innerWidth/innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(innerWidth, innerHeight);
    });
  </script>
</body>
</html>
