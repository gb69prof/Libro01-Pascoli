<!doctype html>
<html lang="it">
<head>
  <meta charset="utf-8"/>
  <meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"/>
  <title>Dal buio al nido — Pascoli</title>
  <style>
    html,body{margin:0;height:100%;background:#07080b;overflow:hidden;font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
    #wrap{position:fixed;inset:0;}
    canvas{position:absolute;inset:0;width:100%;height:100%;display:block;}
    #fx{pointer-events:none;mix-blend-mode:screen;}
    .hud{position:fixed;left:12px;right:12px;top:12px;display:flex;gap:10px;justify-content:space-between;align-items:center;}
    .chip{backdrop-filter:blur(10px);background:rgba(20,22,28,.45);border:1px solid rgba(255,255,255,.10);
          color:rgba(255,255,255,.88);border-radius:14px;padding:10px 12px;box-shadow:0 10px 30px rgba(0,0,0,.35);}
    .chip b{color:rgba(255,215,140,.95)}
    .controls{position:fixed;bottom:14px;left:14px;right:14px;display:flex;justify-content:space-between;align-items:center;gap:12px;}
    .btn{width:62px;height:62px;border-radius:18px;border:1px solid rgba(255,255,255,.14);background:rgba(255,255,255,.06);
         display:flex;align-items:center;justify-content:center;box-shadow:0 12px 34px rgba(0,0,0,.38);
         backdrop-filter:blur(10px);cursor:pointer;user-select:none;-webkit-tap-highlight-color:transparent;}
    .btn:active{transform:translateY(1px);}
    .btn img{width:34px;height:34px;opacity:.95}
    .speed{flex:1;max-width:520px;margin:0 auto;display:flex;gap:10px;align-items:center;justify-content:center;}
    .speed label{color:rgba(255,255,255,.80);font-size:13px;}
    input[type="range"]{width:min(520px,60vw);}
    .vignette{position:fixed;inset:0;pointer-events:none;
      background:radial-gradient(ellipse at center, rgba(0,0,0,0.06) 0%, rgba(0,0,0,0.55) 70%, rgba(0,0,0,0.92) 100%);}
  </style>
</head>
<body>
<div id="wrap">
  <canvas id="gl"></canvas>
  <canvas id="fx"></canvas>
</div>

<div class="hud">
  <div class="chip"><b>Dal buio al nido</b> — attraversa l’immagine delle tragedie: esplode e si apre il riparo.</div>
  <div class="chip" id="hint">Frecce per muoverti · cursore per velocità</div>
</div>

<div class="controls">
  <div class="btn" id="back" aria-label="Indietro"><img src="assets/arrow_left.svg" alt=""></div>
  <div class="speed">
    <label for="spd">Velocità</label>
    <input id="spd" type="range" min="0.2" max="2.2" step="0.05" value="1.0"/>
  </div>
  <div class="btn" id="forward" aria-label="Avanti"><img src="assets/arrow_right.svg" alt=""></div>
</div>

<div class="vignette"></div>

<script>
(() => {
  const clamp = (v,a,b)=>Math.max(a,Math.min(b,v));
  const lerp = (a,b,t)=>a+(b-a)*t;

  const canvas = document.getElementById('gl');
  const fx = document.getElementById('fx');
  const btnF = document.getElementById('forward');
  const btnB = document.getElementById('back');
  const spd = document.getElementById('spd');

  const gl = canvas.getContext('webgl', {alpha:false, antialias:true});
  if(!gl){ alert('WebGL non disponibile.'); return; }

  const vs = `
    attribute vec3 aPos;
    attribute vec2 aUV;
    uniform mat4 uMVP;
    varying vec2 vUV;
    void main(){ vUV=aUV; gl_Position=uMVP*vec4(aPos,1.0); }
  `;
  const fs = `
    precision mediump float;
    varying vec2 vUV;
    uniform sampler2D uTex;
    uniform float uAlpha;
    uniform float uFade;
    void main(){
      vec4 c = texture2D(uTex, vUV);
      c.rgb = mix(vec3(0.0), c.rgb, uFade);
      gl_FragColor = vec4(c.rgb, c.a*uAlpha);
    }
  `;
  function compile(type, src){
    const s = gl.createShader(type);
    gl.shaderSource(s, src); gl.compileShader(s);
    if(!gl.getShaderParameter(s, gl.COMPILE_STATUS)){ console.error(gl.getShaderInfoLog(s)); throw new Error('shader'); }
    return s;
  }
  function program(vsSrc, fsSrc){
    const p = gl.createProgram();
    gl.attachShader(p, compile(gl.VERTEX_SHADER, vsSrc));
    gl.attachShader(p, compile(gl.FRAGMENT_SHADER, fsSrc));
    gl.linkProgram(p);
    if(!gl.getProgramParameter(p, gl.LINK_STATUS)){ console.error(gl.getProgramInfoLog(p)); throw new Error('link'); }
    return p;
  }
  const prog = program(vs, fs);
  gl.useProgram(prog);

  const locPos = gl.getAttribLocation(prog, 'aPos');
  const locUV = gl.getAttribLocation(prog, 'aUV');
  const locMVP = gl.getUniformLocation(prog, 'uMVP');
  const locAlpha = gl.getUniformLocation(prog, 'uAlpha');
  const locFade = gl.getUniformLocation(prog, 'uFade');

  const quad = new Float32Array([
    -1,-1,0,  0,1,
     1,-1,0,  1,1,
     1, 1,0,  1,0,
    -1, 1,0,  0,0,
  ]);
  const idx = new Uint16Array([0,1,2, 0,2,3]);
  const vbo = gl.createBuffer(); gl.bindBuffer(gl.ARRAY_BUFFER, vbo); gl.bufferData(gl.ARRAY_BUFFER, quad, gl.STATIC_DRAW);
  const ibo = gl.createBuffer(); gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, ibo); gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, idx, gl.STATIC_DRAW);
  gl.enableVertexAttribArray(locPos); gl.vertexAttribPointer(locPos, 3, gl.FLOAT, false, 20, 0);
  gl.enableVertexAttribArray(locUV); gl.vertexAttribPointer(locUV, 2, gl.FLOAT, false, 20, 12);

  function loadTex(url){
    return new Promise((resolve,reject)=>{
      const img = new Image();
      img.onload = () => {
        const tex = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, tex);
        gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
        gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, img);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        resolve({tex, w:img.width, h:img.height});
      };
      img.onerror = reject;
      img.src = url;
    });
  }

  function mat4Identity(){ return [1,0,0,0, 0,1,0,0, 0,0,1,0, 0,0,0,1]; }
  function mat4Mul(a,b){
    const o = new Array(16);
    for(let r=0;r<4;r++) for(let c=0;c<4;c++){
      o[r*4+c] = a[r*4+0]*b[0*4+c] + a[r*4+1]*b[1*4+c] + a[r*4+2]*b[2*4+c] + a[r*4+3]*b[3*4+c];
    }
    return o;
  }
  function mat4Translate(x,y,z){ const m=mat4Identity(); m[12]=x; m[13]=y; m[14]=z; return m; }
  function mat4Scale(x,y,z){ const m=mat4Identity(); m[0]=x; m[5]=y; m[10]=z; return m; }
  function mat4Perspective(fovy, aspect, near, far){
    const f = 1/Math.tan(fovy/2), nf = 1/(near-far);
    return [f/aspect,0,0,0, 0,f,0,0, 0,0,(far+near)*nf,-1, 0,0,(2*far*near)*nf,0];
  }

  function resize(){
    const dpr = Math.min(2, window.devicePixelRatio || 1);
    canvas.width = Math.floor(canvas.clientWidth * dpr);
    canvas.height = Math.floor(canvas.clientHeight * dpr);
    fx.width = canvas.width; fx.height = canvas.height;
    gl.viewport(0,0,canvas.width,canvas.height);
  }
  window.addEventListener('resize', resize); resize();

  // particles overlay
  const ctx = fx.getContext('2d');
  let particles = [];
  function explode(){
    const cx = fx.width*0.5, cy = fx.height*0.52;
    particles = [];
    for(let i=0;i<220;i++){
      const a = Math.random()*Math.PI*2;
      const sp = 2 + Math.random()*10;
      particles.push({x:cx,y:cy,vx:Math.cos(a)*sp,vy:Math.sin(a)*sp*0.8,life:900+Math.random()*500,r:1+Math.random()*3.5,h:38+Math.random()*30});
    }
  }
  function drawFX(dt){
    ctx.clearRect(0,0,fx.width,fx.height);
    if(particles.length===0) return;
    ctx.globalCompositeOperation='lighter';
    for(const p of particles){
      p.life -= dt; if(p.life<=0) continue;
      p.vx *= 0.985; p.vy = p.vy*0.985 + 0.02;
      p.x += p.vx; p.y += p.vy;
      const a = clamp(p.life/1200,0,1);
      ctx.fillStyle = `hsla(${p.h},90%,70%,${a*0.85})`;
      ctx.beginPath(); ctx.arc(p.x,p.y,p.r,0,Math.PI*2); ctx.fill();
    }
    particles = particles.filter(p=>p.life>0);
    ctx.globalCompositeOperation='source-over';
  }

  const Z_TRAG = -8.0;
  const Z_NIDO = -28.0;

  let camZ = 0.0;
  let vel = 0.035;
  let moving = 0;

  let triggered=false, showTrag=true, showNido=false;
  let fadeTrag=1.0, fadeNido=0.0, nidoIntro=false;

  const press = (el,dir) => {
    const start = ()=>moving=dir;
    const end = ()=>moving=0;
    el.addEventListener('pointerdown',(e)=>{ e.preventDefault(); el.setPointerCapture(e.pointerId); start(); });
    el.addEventListener('pointerup', end);
    el.addEventListener('pointercancel', end);
    el.addEventListener('pointerleave', end);
  };
  press(btnF, +1); press(btnB, -1);
  window.addEventListener('keydown',(e)=>{
    if(e.key==='ArrowRight'||e.key==='ArrowUp') moving=+1;
    if(e.key==='ArrowLeft'||e.key==='ArrowDown') moving=-1;
  });
  window.addEventListener('keyup',(e)=>{
    if(['ArrowRight','ArrowUp','ArrowLeft','ArrowDown'].includes(e.key)) moving=0;
  });

  gl.enable(gl.DEPTH_TEST);
  gl.enable(gl.BLEND);
  gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);

  function clear(){
    gl.clearColor(0.02,0.03,0.05,1);
    gl.clear(gl.COLOR_BUFFER_BIT|gl.DEPTH_BUFFER_BIT);
  }

  function drawBillboard(texInfo, z, fade, alpha){
    const aspect = texInfo.w/texInfo.h;
    const canvasAspect = canvas.width/canvas.height;
    let sx = 3.2, sy = 3.2/aspect;
    if(canvasAspect < 1.1){ sx = 2.6; sy = 2.6/aspect; }

    const model = mat4Mul(mat4Translate(0,0.2,z), mat4Scale(sx,sy,1));
    const proj = mat4Perspective(55*Math.PI/180, canvasAspect, 0.1, 100);
    const view = mat4Translate(0,0,-camZ);
    const mvp = mat4Mul(proj, mat4Mul(view, model));

    gl.uniformMatrix4fv(locMVP, false, new Float32Array(mvp));
    gl.uniform1f(locAlpha, alpha);
    gl.uniform1f(locFade, fade);

    gl.activeTexture(gl.TEXTURE0);
    gl.bindTexture(gl.TEXTURE_2D, texInfo.tex);
    gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);
  }

  Promise.all([loadTex('assets/tragedie.png'), loadTex('assets/nido.png')]).then(([trag,nido])=>{
    let last = performance.now();
    function tick(now){
      const dt = now-last; last=now;

      camZ += moving * vel * parseFloat(spd.value) * dt;
      camZ = clamp(camZ, -40, 4);

      if(!triggered && camZ < (Z_TRAG - 0.6)){
        triggered=true;
        explode();
        showNido=true;
        nidoIntro=true;
      }

      if(triggered){
        fadeTrag = lerp(fadeTrag, 0.0, 0.04);
        fadeNido = lerp(fadeNido, 1.0, 0.03);
        if(fadeTrag < 0.02) showTrag=false;

        if(nidoIntro){
          const target = -18.0;
          camZ = lerp(camZ, target, 0.02);
          if(Math.abs(camZ-target) < 0.2) nidoIntro=false;
        }
      }

      clear();

      // faint grain/corridor mood
      drawBillboard(trag, -18.0, 0.35, 0.06);

      if(showTrag) drawBillboard(trag, Z_TRAG, 1.0, 1.0*fadeTrag);
      if(showNido) drawBillboard(nido, Z_NIDO, 1.0, 1.0*fadeNido);

      drawFX(dt);
      requestAnimationFrame(tick);
    }
    requestAnimationFrame(tick);
  }).catch(err=>{
    console.error(err);
    alert('Errore nel caricamento delle immagini.');
  });

})();
</script>
</body>
</html>
